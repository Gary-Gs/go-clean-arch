
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Gary-Gs/go-clean-arch/article/delivery/http/article_handler.go (70.2%)</option>
				
				<option value="file1">github.com/Gary-Gs/go-clean-arch/article/delivery/http/middleware/middleware.go (100.0%)</option>
				
				<option value="file2">github.com/Gary-Gs/go-clean-arch/article/repository/mysql/mysql_article.go (72.1%)</option>
				
				<option value="file3">github.com/Gary-Gs/go-clean-arch/article/usecase/article_ucase.go (89.9%)</option>
				
				<option value="file4">github.com/Gary-Gs/go-clean-arch/author/repository/mysql/mysql_repository.go (90.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "net/http"
        "strconv"

        "github.com/labstack/echo"
        "github.com/sirupsen/logrus"
        validator "gopkg.in/go-playground/validator.v9"

        "github.com/Gary-Gs/go-clean-arch/domain"
)

// ResponseError represent the reseponse error struct
type ResponseError struct {
        Message string `json:"message"`
}

// ArticleHandler  represent the httphandler for article
type ArticleHandler struct {
        AUsecase domain.ArticleUsecase
}

// NewArticleHandler will initialize the articles/ resources endpoint
func NewArticleHandler(e *echo.Echo, us domain.ArticleUsecase) <span class="cov0" title="0">{
        handler := &amp;ArticleHandler{
                AUsecase: us,
        }
        e.GET("/articles", handler.FetchArticle)
        e.POST("/articles", handler.Store)
        e.GET("/articles/:id", handler.GetByID)
        e.DELETE("/articles/:id", handler.Delete)
}</span>

// FetchArticle will fetch the article based on given params
func (a *ArticleHandler) FetchArticle(c echo.Context) error <span class="cov8" title="1">{
        numS := c.QueryParam("num")
        num, _ := strconv.Atoi(numS)
        cursor := c.QueryParam("cursor")
        ctx := c.Request().Context()

        listAr, nextCursor, err := a.AUsecase.Fetch(ctx, cursor, int64(num))
        if err != nil </span><span class="cov8" title="1">{
                return c.JSON(getStatusCode(err), ResponseError{Message: err.Error()})
        }</span>

        <span class="cov8" title="1">c.Response().Header().Set(`X-Cursor`, nextCursor)
        return c.JSON(http.StatusOK, listAr)</span>
}

// GetByID will get article by given id
func (a *ArticleHandler) GetByID(c echo.Context) error <span class="cov8" title="1">{
        idP, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, domain.ErrNotFound.Error())
        }</span>

        <span class="cov8" title="1">id := int64(idP)
        ctx := c.Request().Context()

        art, err := a.AUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(getStatusCode(err), ResponseError{Message: err.Error()})
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, art)</span>
}

func isRequestValid(m *domain.Article) (bool, error) <span class="cov8" title="1">{
        validate := validator.New()
        err := validate.Struct(m)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// Store will store the article by given request body
func (a *ArticleHandler) Store(c echo.Context) (err error) <span class="cov8" title="1">{
        var article domain.Article
        err = c.Bind(&amp;article)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnprocessableEntity, err.Error())
        }</span>

        <span class="cov8" title="1">var ok bool
        if ok, err = isRequestValid(&amp;article); !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">ctx := c.Request().Context()
        err = a.AUsecase.Store(ctx, &amp;article)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(getStatusCode(err), ResponseError{Message: err.Error()})
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, article)</span>
}

// Delete will delete article by given param
func (a *ArticleHandler) Delete(c echo.Context) error <span class="cov8" title="1">{
        idP, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, domain.ErrNotFound.Error())
        }</span>

        <span class="cov8" title="1">id := int64(idP)
        ctx := c.Request().Context()

        err = a.AUsecase.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(getStatusCode(err), ResponseError{Message: err.Error()})
        }</span>

        <span class="cov8" title="1">return c.NoContent(http.StatusNoContent)</span>
}

func getStatusCode(err error) int <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return http.StatusOK
        }</span>

        <span class="cov8" title="1">logrus.Error(err)
        switch err </span>{
        case domain.ErrInternalServerError:<span class="cov8" title="1">
                return http.StatusInternalServerError</span>
        case domain.ErrNotFound:<span class="cov0" title="0">
                return http.StatusNotFound</span>
        case domain.ErrConflict:<span class="cov0" title="0">
                return http.StatusConflict</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import "github.com/labstack/echo"

// GoMiddleware represent the data-struct for middleware
type GoMiddleware struct {
        // another stuff , may be needed by middleware
}

// CORS will handle the CORS middleware
func (m *GoMiddleware) CORS(next echo.HandlerFunc) echo.HandlerFunc <span class="cov8" title="1">{
        return func(c echo.Context) error </span><span class="cov8" title="1">{
                c.Response().Header().Set("Access-Control-Allow-Origin", "*")
                return next(c)
        }</span>
}

// InitMiddleware initialize the middleware
func InitMiddleware() *GoMiddleware <span class="cov8" title="1">{
        return &amp;GoMiddleware{}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package mysql

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/sirupsen/logrus"

        "github.com/Gary-Gs/go-clean-arch/article/repository"
        "github.com/Gary-Gs/go-clean-arch/domain"
)

type mysqlArticleRepository struct {
        Conn *sql.DB
}

// NewMysqlArticleRepository will create an object that represent the article.Repository interface
func NewMysqlArticleRepository(Conn *sql.DB) domain.ArticleRepository <span class="cov8" title="1">{
        return &amp;mysqlArticleRepository{Conn}
}</span>

func (m *mysqlArticleRepository) fetch(ctx context.Context, query string, args ...interface{}) (result []domain.Article, err error) <span class="cov8" title="1">{
        rows, err := m.Conn.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                errRow := rows.Close()
                if errRow != nil </span><span class="cov0" title="0">{
                        logrus.Error(errRow)
                }</span>
        }()

        <span class="cov8" title="1">result = make([]domain.Article, 0)
        for rows.Next() </span><span class="cov8" title="1">{
                t := domain.Article{}
                authorID := int64(0)
                err = rows.Scan(
                        &amp;t.ID,
                        &amp;t.Title,
                        &amp;t.Content,
                        &amp;authorID,
                        &amp;t.UpdatedAt,
                        &amp;t.CreatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">t.Author = domain.Author{
                        ID: authorID,
                }
                result = append(result, t)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (m *mysqlArticleRepository) Fetch(ctx context.Context, cursor string, num int64) (res []domain.Article, nextCursor string, err error) <span class="cov8" title="1">{
        query := `SELECT id,title,content, author_id, updated_at, created_at
                                                  FROM article WHERE created_at &gt; ? ORDER BY created_at LIMIT ? `

        decodedCursor, err := repository.DecodeCursor(cursor)
        if err != nil &amp;&amp; cursor != "" </span><span class="cov0" title="0">{
                return nil, "", domain.ErrBadParamInput
        }</span>

        <span class="cov8" title="1">res, err = m.fetch(ctx, query, decodedCursor, num)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">if len(res) == int(num) </span><span class="cov8" title="1">{
                nextCursor = repository.EncodeCursor(res[len(res)-1].CreatedAt)
        }</span>

        <span class="cov8" title="1">return</span>
}
func (m *mysqlArticleRepository) GetByID(ctx context.Context, id int64) (res domain.Article, err error) <span class="cov8" title="1">{
        query := `SELECT id,title,content, author_id, updated_at, created_at
                                                  FROM article WHERE ID = ?`

        list, err := m.fetch(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Article{}, err
        }</span>

        <span class="cov8" title="1">if len(list) &gt; 0 </span><span class="cov8" title="1">{
                res = list[0]
        }</span> else<span class="cov0" title="0"> {
                return res, domain.ErrNotFound
        }</span>

        <span class="cov8" title="1">return</span>
}

func (m *mysqlArticleRepository) GetByTitle(ctx context.Context, title string) (res domain.Article, err error) <span class="cov8" title="1">{
        query := `SELECT id,title,content, author_id, updated_at, created_at
                                                  FROM article WHERE title = ?`

        list, err := m.fetch(ctx, query, title)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(list) &gt; 0 </span><span class="cov8" title="1">{
                res = list[0]
        }</span> else<span class="cov0" title="0"> {
                return res, domain.ErrNotFound
        }</span>
        <span class="cov8" title="1">return</span>
}

func (m *mysqlArticleRepository) Store(ctx context.Context, a *domain.Article) (err error) <span class="cov8" title="1">{
        query := `INSERT  article SET title=? , content=? , author_id=?, updated_at=? , created_at=?`
        stmt, err := m.Conn.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">res, err := stmt.ExecContext(ctx, a.Title, a.Content, a.Author.ID, a.UpdatedAt, a.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lastID, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">a.ID = lastID
        return</span>
}

func (m *mysqlArticleRepository) Delete(ctx context.Context, id int64) (err error) <span class="cov8" title="1">{
        query := "DELETE FROM article WHERE id = ?"

        stmt, err := m.Conn.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">res, err := stmt.ExecContext(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rowsAfected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if rowsAfected != 1 </span><span class="cov0" title="0">{
                err = fmt.Errorf("Weird  Behavior. Total Affected: %d", rowsAfected)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}
func (m *mysqlArticleRepository) Update(ctx context.Context, ar *domain.Article) (err error) <span class="cov8" title="1">{
        query := `UPDATE article set title=?, content=?, author_id=?, updated_at=? WHERE ID = ?`

        stmt, err := m.Conn.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">res, err := stmt.ExecContext(ctx, ar.Title, ar.Content, ar.Author.ID, ar.UpdatedAt, ar.ID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">affect, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if affect != 1 </span><span class="cov0" title="0">{
                err = fmt.Errorf("Weird  Behavior. Total Affected: %d", affect)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecase

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"

        "github.com/Gary-Gs/go-clean-arch/domain"
)

type articleUsecase struct {
        articleRepo    domain.ArticleRepository
        authorRepo     domain.AuthorRepository
        contextTimeout time.Duration
}

// NewArticleUsecase will create new an articleUsecase object representation of domain.ArticleUsecase interface
func NewArticleUsecase(a domain.ArticleRepository, ar domain.AuthorRepository, timeout time.Duration) domain.ArticleUsecase <span class="cov8" title="1">{
        return &amp;articleUsecase{
                articleRepo:    a,
                authorRepo:     ar,
                contextTimeout: timeout,
        }
}</span>

/*
* In this function below, I'm using errgroup with the pipeline pattern
* Look how this works in this package explanation
* in godoc: https://godoc.org/golang.org/x/sync/errgroup#ex-Group--Pipeline
 */
func (a *articleUsecase) fillAuthorDetails(c context.Context, data []domain.Article) ([]domain.Article, error) <span class="cov8" title="1">{
        g, ctx := errgroup.WithContext(c)

        // Get the author's id
        mapAuthors := map[int64]domain.Author{}

        for _, article := range data </span><span class="cov8" title="1">{
                mapAuthors[article.Author.ID] = domain.Author{}
        }</span>
        // Using goroutine to fetch the author's detail
        <span class="cov8" title="1">chanAuthor := make(chan domain.Author)
        for authorID := range mapAuthors </span><span class="cov8" title="1">{
                authorID := authorID
                g.Go(func() error </span><span class="cov8" title="1">{
                        res, err := a.authorRepo.GetByID(ctx, authorID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">chanAuthor &lt;- res
                        return nil</span>
                })
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                err := g.Wait()
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(err)
                        return
                }</span>
                <span class="cov8" title="1">close(chanAuthor)</span>
        }()

        <span class="cov8" title="1">for author := range chanAuthor </span><span class="cov8" title="1">{
                if author != (domain.Author{}) </span><span class="cov8" title="1">{
                        mapAuthors[author.ID] = author
                }</span>
        }

        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // merge the author's data
        <span class="cov8" title="1">for index, item := range data </span><span class="cov8" title="1">{
                if a, ok := mapAuthors[item.Author.ID]; ok </span><span class="cov8" title="1">{
                        data[index].Author = a
                }</span>
        }
        <span class="cov8" title="1">return data, nil</span>
}

func (a *articleUsecase) Fetch(c context.Context, cursor string, num int64) (res []domain.Article, nextCursor string, err error) <span class="cov8" title="1">{
        if num == 0 </span><span class="cov0" title="0">{
                num = 10
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(c, a.contextTimeout)
        defer cancel()

        res, nextCursor, err = a.articleRepo.Fetch(ctx, cursor, num)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">res, err = a.fillAuthorDetails(ctx, res)
        if err != nil </span><span class="cov0" title="0">{
                nextCursor = ""
        }</span>
        <span class="cov8" title="1">return</span>
}

func (a *articleUsecase) GetByID(c context.Context, id int64) (res domain.Article, err error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, a.contextTimeout)
        defer cancel()

        res, err = a.articleRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">resAuthor, err := a.authorRepo.GetByID(ctx, res.Author.ID)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Article{}, err
        }</span>
        <span class="cov8" title="1">res.Author = resAuthor
        return</span>
}

func (a *articleUsecase) Update(c context.Context, ar *domain.Article) (err error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, a.contextTimeout)
        defer cancel()

        ar.UpdatedAt = time.Now()
        return a.articleRepo.Update(ctx, ar)
}</span>

func (a *articleUsecase) GetByTitle(c context.Context, title string) (res domain.Article, err error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, a.contextTimeout)
        defer cancel()
        res, err = a.articleRepo.GetByTitle(ctx, title)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">resAuthor, err := a.authorRepo.GetByID(ctx, res.Author.ID)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Article{}, err
        }</span>

        <span class="cov8" title="1">res.Author = resAuthor
        return</span>
}

func (a *articleUsecase) Store(c context.Context, m *domain.Article) (err error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, a.contextTimeout)
        defer cancel()
        existedArticle, _ := a.GetByTitle(ctx, m.Title)
        if existedArticle != (domain.Article{}) </span><span class="cov8" title="1">{
                return domain.ErrConflict
        }</span>

        <span class="cov8" title="1">err = a.articleRepo.Store(ctx, m)
        return</span>
}

func (a *articleUsecase) Delete(c context.Context, id int64) (err error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, a.contextTimeout)
        defer cancel()
        existedArticle, err := a.articleRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if existedArticle == (domain.Article{}) </span><span class="cov8" title="1">{
                return domain.ErrNotFound
        }</span>
        <span class="cov8" title="1">return a.articleRepo.Delete(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package mysql

import (
        "context"
        "database/sql"

        "github.com/Gary-Gs/go-clean-arch/domain"
)

type mysqlAuthorRepo struct {
        DB *sql.DB
}

// NewMysqlAuthorRepository will create an implementation of author.Repository
func NewMysqlAuthorRepository(db *sql.DB) domain.AuthorRepository <span class="cov8" title="1">{
        return &amp;mysqlAuthorRepo{
                DB: db,
        }
}</span>

func (m *mysqlAuthorRepo) getOne(ctx context.Context, query string, args ...interface{}) (res domain.Author, err error) <span class="cov8" title="1">{
        stmt, err := m.DB.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Author{}, err
        }</span>
        <span class="cov8" title="1">row := stmt.QueryRowContext(ctx, args...)
        res = domain.Author{}

        err = row.Scan(
                &amp;res.ID,
                &amp;res.Name,
                &amp;res.CreatedAt,
                &amp;res.UpdatedAt,
        )
        return</span>
}

func (m *mysqlAuthorRepo) GetByID(ctx context.Context, id int64) (domain.Author, error) <span class="cov8" title="1">{
        query := `SELECT id, name, created_at, updated_at FROM author WHERE id=?`
        return m.getOne(ctx, query, id)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
